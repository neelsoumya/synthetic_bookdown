[["generating-data-using-simstudy-methods.html", "Chapter 4 Generating data using simstudy methods 4.1 Brief comments on the validity of the data", " Chapter 4 Generating data using simstudy methods In this chapter we will look at how to generate synthetic data on the client side using DataSHIELD functions to extract summary characteristics of the data set from the server side. Again we need to build a login object for the server that holds the data. Note that the dsSynthetic functions have been written to work with a single connection: builder &lt;- DSI::newDSLoginBuilder() # hide credentials builder$append(server=&quot;server1&quot;, url=&quot;https://opal-sandbox.mrc-epid.cam.ac.uk&quot;, user=&quot;dsuser&quot;, password=&quot;password&quot;, table = &quot;DASIM.DASIM1&quot;) logindata &lt;- builder$build() And then we establish a connection to the server: library(DSOpal) if(exists(&quot;connections&quot;)){ datashield.logout(conns = connections) } connections &lt;- datashield.login(logins=logindata, assign = TRUE) This method builds on the fundamentals of the simstudy package. There is a good introduction to this package here. First we load the library library(&quot;simstudy&quot;) library(&quot;dsBaseClient&quot;) library(&quot;dsSyntheticClient&quot;) The simstudy method uses a function called genCorFlex (see simstudy help for more details). This function is currently not able to support categorical distributions, but does support binary distributions. Therefore we need to convert factor variables with more than 2 levels into a series of binary dummy variables. For example, the PM_BMI_CATEGORICAL variable has levels 1, 2 and 3. This will need to be converted into 2 binary variables with 2 levels. A helper function is provided to make this process easier. ds.binary.helper(dataframe = &quot;D&quot;, factor_variables = &quot;PM_BMI_CATEGORICAL&quot;, newobj = &quot;my.bin&quot;, datasources = connections) ## $server1 ## $server1$return.message ## [1] &quot;Object(s) &#39;dummy,X1_PM_BMI_CATEGORICAL,X2_PM_BMI_CATEGORICAL,temp_mat&#39; was deleted.&quot; ## ## $server1$deleted.objects ## [1] &quot;dummy,X1_PM_BMI_CATEGORICAL,X2_PM_BMI_CATEGORICAL,temp_mat&quot; ## ## $server1$missing.objects ## [1] &quot;&quot; ## ## $server1$problem.objects ## [1] &quot;&quot; Looking at the new dataframe, which has the 2 binary variables in it: ds.summary(&quot;my.bin&quot;, datasources = connections) ## $server1 ## $server1$class ## [1] &quot;data.frame&quot; ## ## $server1$`number of rows` ## [1] 10000 ## ## $server1$`number of columns` ## [1] 2 ## ## $server1$`variables held` ## [1] &quot;X1_PM_BMI_CATEGORICAL&quot; &quot;X2_PM_BMI_CATEGORICAL&quot; We will make a new dataframe without the original PM_BMI_CATEGORICAL variable but with the new binaries: vars = c(&quot;LAB_TSC&quot;, &quot;LAB_TRIG&quot;, &quot;LAB_HDL&quot;, &quot;LAB_GLUC_FASTING&quot;, &quot;PM_BMI_CONTINUOUS&quot;, &quot;DIS_CVA&quot;, &quot;DIS_DIAB&quot;, &quot;DIS_AMI&quot;, &quot;GENDER&quot;) ds.subset(x=&quot;D&quot;, subset=&quot;D2&quot;, cols=vars, datasources = connections) ds.dataFrame(x = c(&quot;D2&quot;,&quot;my.bin&quot;), newobj = &quot;new_frame&quot;, datasources = connections) ## $is.object.created ## [1] &quot;A data object &lt;new_frame&gt; has been created in all specified data sources&quot; ## ## $validity.check ## [1] &quot;&lt;new_frame&gt; appears valid in all sources&quot; Now we are ready to generate the synthetic data using the ds.genCorFlex.helper function. We need to provide a vector of continuous variables and factor variables: cont_vars = c(&quot;LAB_TSC&quot;, &quot;LAB_TRIG&quot;, &quot;LAB_HDL&quot;, &quot;LAB_GLUC_FASTING&quot;, &quot;PM_BMI_CONTINUOUS&quot;) factor_vars = c( &quot;DIS_CVA&quot;, &quot;DIS_DIAB&quot;, &quot;DIS_AMI&quot;, &quot;GENDER&quot;, &quot;X1_PM_BMI_CATEGORICAL&quot;, &quot;X2_PM_BMI_CATEGORICAL&quot;) dd = ds.genCorFlex.helper(dataframe = &quot;new_frame&quot;, cont_variables = cont_vars, factor_variables = factor_vars, num_rows = 10000, datasources = connections) ## Warning: &#39;ds.subset&#39; is deprecated. ## Use &#39;ds.dataFrameSubset&#39; instead. ## See help(&quot;Deprecated&quot;) If all has gone well the synthetic data should have a similar structure and properties to the real data: head(dd) ## id DIS_CVA_num DIS_DIAB_num DIS_AMI_num GENDER_num X1_PM_BMI_CATEGORICAL_num ## 1: 1 0 0 0 1 0 ## 2: 2 0 0 0 1 0 ## 3: 3 0 0 0 1 0 ## 4: 4 0 0 0 1 0 ## 5: 5 0 0 0 1 1 ## 6: 6 0 0 0 0 1 ## X2_PM_BMI_CATEGORICAL_num LAB_TSC LAB_TRIG LAB_HDL LAB_GLUC_FASTING ## 1: 0 5.377074 0.4505604 1.875910 3.031899 ## 2: 0 5.155637 -0.1258161 2.480051 4.359498 ## 3: 0 3.919156 -0.6081210 2.045550 4.303939 ## 4: 0 6.594628 1.0112899 1.901013 5.156636 ## 5: 0 3.296433 1.4643091 1.295242 5.392629 ## 6: 0 6.795899 2.1064403 1.407495 5.247895 ## PM_BMI_CONTINUOUS ## 1: 26.10608 ## 2: 20.25187 ## 3: 26.94817 ## 4: 26.07796 ## 5: 29.24621 ## 6: 30.18560 We can reconstruct the PM_BMI_CATEGORICAL variable as follows: dd$PM_BMI_CATEGORICAL = 1 + dd$X1_PM_BMI_CATEGORICAL_num + dd$X2_PM_BMI_CATEGORICAL_num Such that it now has levels 1, 2 and 3. 4.1 Brief comments on the validity of the data In the example above we chose to synthetically generate the variable PM_BMI_CATEGORICAL. This variable is actually derived from the continuous variable PM_BMI_CONTINUOUS, with (say) BMI &lt;25 being category 1, 25&lt;= BMI &lt; 30 being category 2 etc. Becuase of the probabilistic way in which the data are generated, this categorisation is not enforced in the data synthesis. It might be better to generate the continuous variable only and add the categorical variable afterwards. "]]
